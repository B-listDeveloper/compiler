structure A = Absyn
structure S = Symbol

%%

%pos ErrorMsg.pos
%verbose
%eop EOF
%noshift EOF
%name Fun
%term EOF
| INT of int
| ID of string
| PROJ of int
| ARROW | FUN | IN | LET | ELSE | THEN | IF 
| ASSIGN | BANG | REF | DO | WHILE | OR | NOT 
| AND | GT | EQ | LT | TIMES | MINUS | UMINUS
| PLUS | RPAREN | LPAREN | COLON | SEMICOLON | COMMA

%nonterm tp of A.tp | tps of A.tp list
| exp of A.exp | exps of A.exp list
| func of A.func
| fundec of A.fundec | fundecs of A.fundec list
| prog of A.prog

%right ARROW
%nonassoc LET IN
%nonassoc SEMICOLON
%nonassoc IF THEN ELSE DO WHILE
%right ASSIGN
%nonassoc COLON
%left AND OR
%nonassoc NOT
%left LT EQ
%left PLUS MINUS
%left TIMES
%nonassoc PROJ REF BANG UMINUS

%start prog

%%

(* Program Structure *)
prog:                               (nil)
| fundec prog                       (fundec :: prog)

func:
ID LPAREN ID COLON tp RPAREN COLON tp EQ exp
                                    ((S.symbol(ID1), S.symbol(ID2), tp1, tp2, exp1))

(* Function Declaration Structure *)
fundec:
FUN func                            (((FUNleft, func1right), func))

(* Type Structure *)
tp:
(* int *)
ID                                  (A.Inttp)
(* <tp, ..., tp> *)
| LT tps GT                         (A.Tupletp(tps))
(* tp -> tp *)
| tp ARROW tp                       (A.Arrowtp(tp1, tp2))
(* tp ref *)
| tp REF                            (A.Reftp(tp1))
(* (tp) *)
| LPAREN tp RPAREN                  (tp1)

tps:                                (nil)
| tp                                ([tp1])
| tp COMMA tps                      (tp1 :: tps)

(* Expression Structure *)
exp:
(* (exp) *)
LPAREN exp RPAREN                   (A.Pos((exp1left, RPARENright), exp1))
(* id *)
| ID                                (A.Id(S.symbol(ID)))
(* num *)
| INT                               (A.Int(INT))
(* exp; exp *)
| exp SEMICOLON exp                 (A.Let(S.symbol(NONE), exp1, exp2))
(* un exp *)
| MINUS exp %prec UMINUS            (A.Op(A.Sub, [A.Int(0), exp1]))
| NOT exp                           (A.If(A.Op(A.Eq, [exp1, A.Int(0)]), A.Int(1), A.Int(0)))
| BANG exp                          (A.Op(A.Get, [exp1]))
| PROJ exp                          (A.Proj(PROJ, exp1))
(* exp bin exp *)
| exp PLUS exp                      (A.Op(A.Add, [exp1, exp2]))
| exp MINUS exp                     (A.Op(A.Sub, [exp1, exp2]))
| exp TIMES exp                     (A.Op(A.Mul, [exp1, exp2]))
| exp AND exp                       (A.If(exp1, A.If(exp2, A.Int(1), A.Int(0)), A.Int(0)))
| exp OR exp                        (A.If(exp1, A.Int(1), A.If(exp2, A.Int(1), A.Int(0))))
| exp EQ exp                        (A.Op(A.Eq, [exp1, exp2]))
| exp GT exp                        (A.If(A.Op(A.LT, [exp1, exp2]), A.Int(0), A.If(A.Op(A.Eq, [exp1, exp2]), A.Int(0), A.Int(1))))
| exp LT exp                        (A.Op(A.LT, [exp1, exp2]))
| exp ASSIGN exp                    (A.Op(A.Set, [exp1, exp2]))
(* <exp, ..., exp> *)
| LT exps GT                        (A.Tuple(exps))
(* exp ( exp ) *)
| exp LPAREN exp RPAREN             (A.Pos((exp1left, RPARENright), A.Call(exp1, exp2)))
(* exp : tp *)
| exp COLON tp                      (A.Constrain(exp1, tp1))
(* if exp then exp else exp  *)
(*| IF exp THEN exp ELSE exp          () *)
| IF exp THEN exp ELSE exp          (A.If(exp1, exp2, exp3))
(* if exp then exp *)
| IF exp THEN exp                   (A.If(exp1, exp2, A.Tuple([])))
(* while exp do exp *)
| WHILE exp DO exp                  (A.While(exp1, exp2))
(* let id = exp in exp *)
(*| LET ID EQ exp IN exp              ()*)
| LET ID EQ exp IN exp              (A.Let(S.symbol(ID), exp1, exp2))
(* ref exp *)
| REF exp                           (A.Op(A.Ref, [exp1]))

exps:                               (nil)
| exp                               ([exp1])
| exp COMMA exps                    (exp1 :: exps)
